// The Tilde spec is generated with the help of Tilde itself.
// Since Tilde syntax appears throughout, we have to be careful about Tilde's processing of this syntax.
m5_pragma_disable_literal_comma   /// This library was written before the existence of literal commas.
m4_define(['m5_\need_docs'], yes)
m5_use(m5-local)


m5_var(main_doc, <">
   = Tilde Text Processing Language User's Guide
   :toc: macro
   :toclevels: 3
   // Web page meta data.
   :keywords:  Tilde, macro, preprocessor
   :description: Tilde is a macro preprocessor on steroids. It is built on the simple principle of text +
               substitution but provides features and syntax on par with other simple programming languages. +
               It is an easy and capable tack-on enhancement to any text format as well as +
               a reasonable general-purpose programming language specializing in text processing. +
               Its broad applicability makes Tilde a valuable tool in every programmer/engineer/scientist/AI's toolbelt.

   

   //:library: Tilde
   :idprefix: m5_
   :numbered:
   :secnums:
   :sectnumlevels: 4
   :imagesdir: images
   :experimental:
   //:css-signature: m5doc
   //:max-width: 800px
   //:doctype: book
   //:sectids!:
   ifdef::env-github[]
   :note-caption: :information_source:
   :tip-caption: :bulb:
   endif::[]

   [.text-center]
   _To enrich any text format_

   [.text-center]
   Tilde version 1.0, document subversion 1, 2024 +
   by Steve Hoover, Redwood EDA, LLC +
   (mailto:steve.hoover@redwoodeda.com[steve.hoover@redwoodeda.com])

   This document is licensed under the https://creativecommons.org/publicdomain/zero/1.0/legalcode[CC0 1.0 Universal] license.

   Tilde is a simple but capable language for text processing. It is built to extend the capabilities of
   any text file format without getting in the way. It extends concepts of macro preprocessing into the realm
   of programming, restricted to processing text.

   toc::[]

   == Background Information

   === Overview

   {description}

   This chapter provides background and general information about the Tilde language and tool and
   guidance about this specification.


   === About this Specification

   This document covers the Tilde language as well as its standard <<Macro Library>>. This document's major
   version reflects the language version, and the minor version reflects the library version. There is
   also a document subversion distinguishing versions of this document with no corresponding language or
   library changes.

   To target different users, this document contains the following sections:

   - <<Background Information>>
   - <<Getting Started with the Tilde Tool>>
   - <<Reading Tilde Code>>
   - <<Writing Tilde Code>>
   - <<Standard Library Reference>>

   To use Tilde on an existing Tilde file, you only need to read <<Getting Started with the Tilde Tool>>.

   To understand a file that uses Tilde, you only need to read the <<Reading Tilde Code>> and
   consult the <<Standard Library Reference>> as needed.

   To write Tilde code, you need to read the <<Writing Tilde Code>> section as well and become generally
   familiar with the <<Standard Library Reference>>.

   This <<Background Information>> section is optional for everyone.


   === An Overview of Tilde Concepts

   Tilde is built to enhance, not replace, any programming language, text format, or even plain-text file.
   Tilde aims to be:
   
   - non-meddlesome, avoiding any syntax that could conflict with a target language
   - easy to learn to write, and even easier to read
   - capable (not optimal) as a general-purpose language (within the realm of text processing)
   - enabling of custom embedded syntaxes
   - easy to debug (potentially--debugging tools are not yet available)

   Tilde may execute shell commands and can thus be used as a scripting language.

   Libraries are included by URI (URL or local file) and may be cached locally. Thus no library
   installation or package manager is required.

   There are only two data types: text and code. Code is to be evaluated. Text may
   be formatted to represent other data types. For example, a function may produce an
   "integer" value, meaning it produces a string containing the decimal representation of
   an integer value.

   Multiline strings are easily expressed using indentation to avoid the need for escape characters.
   Multiline strings are a great way to make unrestricted embedded formats.

   "Variables" typically hold text string values, and "macros" (most of which are "functions") hold code. Variables and functions
   are global name/value pairs, though each name can hold a stack of values, with the top value being
   active. These stacks are used to provide scoped variables/macros.

   Macros have ordered and (generally) named parameters. They evaluate to strings. The macro
   body is code that contains a series of: literal text strings, variable instantiations, arithmetic
   expressions, and macro calls. Each may append to the output of the function
   or assign/push/pop variables/macros.


   === Use Models

   Tilde can be enabled on any source file in your project. For example, in a Make-based build
   flow, add this to your Makefile:
   
    %: %~
      tilde $< > $@

   To then enable Tilde on any specific source file, simply rename the file with a trailing `~`.
   
   Tilde can also be used to define parameterized web files. A webserver can be configured to serve
   parameterized files using Tilde (similar to PHP). For example,
   `http://example.com/index.html?foo=bar` can invoke Tilde on `index.html~` with a Tilde variable `foo`
   set to `bar` that is used to configure `index.html~`.


   === Tilde's Origin Story

   I created Tilde as a preprocessor for the https://tl-x.org[TL-Verilog] hardware
   language and later decoupled it as a stand-alone tool. The original intent was to use
   an out-of-the box macro preprocessor to provide a stop-gap solutions to missing TL-Verilog language
   features for "code construction" as TL-Verilog took shape. While other hardware languages build on existing
   programming languages to provide code construction, I wanted a simpler approach that would be less
   intimidating to hardware folks. M4 was the obvious choice as the most broadly adopted macro preprocessor.
   
   M4 proved to be capable, but extremely difficult to work with. After a few years
   fighting with an approach that was intended to allow me to focus my attention elsewhere, I
   decided I needed to either find a different approach or clean up the one I had. I felt my struggles
   had led to some worthwhile insights and that there was a place in the
   world for a better text processing language/tool, so I carved out some time to polish my mountain of hacks.

   Though Tilde would benefit from a fresh non-M4/Perl-based implementation, I had to draw the line somewhere.
   At this point, that legacy is mostly behind the scenes, and while it's not everything I'd like it to be,
   it's close, and it's way better than any other text preprocessor I'm aware of.

   So I hope you enjoy the language I never wanted to write. I'm actually rather proud of it and find new uses
   for it every day.


   [[vs_m4]]
   === Tilde Versus M4

   Tilde uses M4 to implement a text-preprocessing language with some subtle philosophical
   differences. Tilde aims to preserve most of the conceptual simplicity of
   macro preprocessing while adding features that improve readability, manageability, and
   debuggability for more complex use cases.

   This document is intended to stand on its own, independent of the
   https://www.gnu.org/software/m4/[M4 documentation]. The M4 documentation
   can, in fact, be confusing due to Tilde's philosophical differences with M4.

   Beyond M4, Tilde contributes:

   - features that feel like a typical, simple programming language
   - literal string variables
   - functions with named parameters
   - variable/macro scope
   - an intentionally minimal amount of syntactic sugar
   - document generation assistance
   - debug aids such as stack traces
   - safer parsing and string manipulation
   - a richer core library of utilities
   - a future plan for modular libraries

   === Limitations of Tilde

   M4 has certain limitations that Tilde is unable to address without a re-implementation that is
   not based on M4 or modifications to M4 itself.

   ==== Security
   M4 has full access to its host environment (similar to most programming and scripting
   languages, but unlike many macro preprocessors). Malware can easily do harm. Third-
   party Tilde code should be carefully vetted before use, or Tilde should be run within a contained
   environment. Tilde provides a simple mechanism for library inclusion by URL (or it will).
   This enables easy execution of public third-party code, so use it with extreme caution.

   ==== Modularity
   M4 does not provide any library, namespace, and version management facilities.
   Though Tilde does not currently address these needs, plans have been sketched in code comments.

   ==== String processing
   While macro processing is all about string processing, safely manipulating arbitrary
   strings is not possible in M4 or it is beyond awkward at best. M4 provides
   `m4_regexp`, `m4_patsubst`, and `m4_substr`. These return unquoted strings that will
   necessarily be elaborated, potentially altering the string. While Tilde is able to jump
   through hoops to provide <<m_regex>> and <<m_substr>> (for strings of limited length)
   that return quoted (literal) text, `m4_patsubst` cannot be fixed (though <<m_for_each_regex>>
   is similar). The result of `m4_patsubst` can be quoted only by quoting the input string,
   which can complicate the match expression, or by ensuring that all text is matched,
   which can be awkward, and quoting substitutions.

   In addition to these issues, care must be taken to ensure that resulting text does not contain mismatching
   quotes or parentheses or combine with surrounding text to result in the same. Such
   resulting mismatches are difficult to debug. Tilde provides a notion of "unquoted strings"
   that can be safely manipulated using <<m_regex>>, and <<m_substr>>.

   Additionally the regex configuration used by M4 is quite dated. For example, it does
   not support lookahead, lazy matches, and character codes.

   ==== Introspection
   Introspection is essentially impossible. The only way to see what is defined is to
   dump definitions to a file and parse this file.

   ==== Recursion
   Recursion has a fixed (command-line) depth limit, and this limit is not applied reliably.

   ==== Unicode
   M4 is an old tool and was built for ASCII text. UTF-8 is now the most common text format.
   It is a superset of ASCII that encodes additional characters as two or more bytes using byte
   codes (0x10-0xFF) that do not conflict by those defined by ASCII (0x00-0x7F). All such bytes
   (0x10-0xFF) are treated as characters by M4 with no special meaning, so these characters
   pass through, unaffected, in macro processing like most others. There are two
   implications to be aware of. First, <<m_length>> provides a length in bytes, not characters.
   Second, <<m_substr>> and regular expressions manipulate bytes, not characters. This can
   result in text being split in the mid-character, resulting in invalid character
   encodings.

   ==== Debugging features
   M4's facilities for associating output with input only map output lines to line numbers of
   top-level calls. M4 does not maintain a call stack with line numbers.

   M4 and Tilde have no debugger to step through code. Printing (see <<m_DEBUG>> is the debugging mechanism of choice.

   ==== Performance
   Tilde is intended for text processing, not for compute-intensive algorithms. Use a programming
   language for that.

   ==== Graphics
   Tilde is for text processing only.

   ==== Status

   This specification documents intended language syntax prior to a clean re-implementation.
   Stay tuned.

   Major next steps include:

   - Implementing a better library system.
   - Some syntactic sugar (quotes, code blocks) should not be recognized in source context.

   See issues file in the https://github.com/rweda/M5[M5 repository] for more details.

   /**
   ==== Futures
   - All literal text must be quoted.
   - Being more explicit about text that should evaluate and text that shouldn't might be better.
   Quote type:
     - `"` for literal text (Note, there is no distinction between begin and end.)
     - `{`/`}` for code (for current implementation, use `[`/`]`). Code must be used as a
     parameter (or use eval sugar).
     - `<'>`/`<'>` for heavily quoted text that may have `\n` and `"` in it. (same begin/end)
     - All of the above followed by a newline for block versions, excluding continuation cases
     (see below).
   - Unquoted whitespace can be ignored!
   - There's no need for `m5_` prefix! Any unquoted text is a macro or variable instantiation.
   - Suddenly, there's no need for code context. There's just quoted context and unquoted context.
   - There's room for other unquoted syntax, like comments, though, maybe `<'>  |` for line comment
   in heavy block quote context, where the ending `<'>` is implied by by "\n"?? Probably not.
   - `"+` for literal quote character within "...". There is nothing else to escape.
   - Require a prefix for "value of"? Yes, "$MyVar". Thus we can:
   - Allow unquoted text as a complete macro argument. Not all characters are permitted.
   This way, variable names and function parameters need not be quoted.
   - Continuation cases return to quote and argument list context that existed previously.
   This affects parenthesis checking and quote-type matching. Currently, this is based on
   returning to a quote level within a line. Link this instead to labeled escape quotes
   (permitting "<>"). Label escapes can be more generic allowing quoting within the escape,
   and we can permit continuation across multiple lines.
   - "*" (for evaluate) is no longer worth it.
   - Added "3.foo" syntax for numbered function parameters to avoid "[".
  
   All other cases are handled by ending the string and starting a new one. And, it's better for
   the escape char to follow the quote since the quote gets you into code context with controlled
   syntax. Otherwise the literal escape char would need an escape char. `-` can also be thought of
   as code syntax for continue text with added `"`. Note that heavy quotes can also be used.
   - We add "heavy block quotes" (`<'>`...`<'>`) to reduce the likelihood of inadvertent end quotes.
   Source context is heavily block quoted.
   - There's no escaping (`m5_\`, `\m5_`).
   - Keep "~" or drop it? Required only when beginning a line?
   - Probably still check for balanced quotes and parens. (Not for constructed code.)
   - Anything to enforce consistent formatting (like in code blocks)? Probably worth it.
   - Allow unquoted numbers. Text that starts with a digit is automatically quoted till the end
   of the word. C-style numbers.
   - Support operators and () in unquoted context for arithmetic? Operators work on text (like
   everything, and that text must represent numbers). Could do full order of operations, only left-
   to-right, or only two operands with nesting, e.g. "((1 + Val) * 3)".
   - No `$1` syntax in the language itself, but this can be supported by a `macro` macro. `arg(2)`
   would call a builtin to access arg 2. Provide other builtins for special M4 `$` syntax.
   - eval("foo(1, 2)") is fine.
   - foo() has zero args; foo("") has one?
   - But... <'>MyVar<'> is clunky. Maybe for heavy text we keep `m5_`/`\m5_` as an/the escape and
   `///`/`/**` for comments??? Maybe just a special case for variables. Needs regex configurability.
   (Post-string substitutions can be performed by wrapping the heavy string in a macro call.)
   - We need to use `~` for something so we can call the language Tilde and give files a `~` extension,
   like `model.tlv~`. Two-line make code to preprocess and run.

   Example:

    Source... blah, blah, blah.<'> # comment <'> Then,
    blah, blah, blah.<'>     | line comment?
    etc.
    <'>

    set(Me, "Steve")
    
    fn(foo, f:{   # f is a label
      "text"
      if(1 || $Cnt, {
        hi()" more text"
      })
      "Hey, "$Player"!"
      if_eq($Val, 2, {hi()"."})
      # A text block with explicit indentation.
      chomp(   # Quote can be on this line as well, as long as the text doesn't start with whitespace.
         "
         Here's a line of text as a block.
      ".)   # "." includes a newline at the end of the block without an extra line.
      
      fn(Hi, {
        "Hi,"f:Me"."   # Me in f: context.
        on_return(<{>set(greeting, {pad("Hi"<}>$ArgList<{>"!")})<}>)
      })
    })<'>
    ...and on we go.
   
   
   ==== Implementation Plan

   Extending Perl `pre_m4` to get most of the benefit (though less simplification to docs):
   - Keep code block `{` and `[` as they are.
   - Keep text blocks as they are.
   - Keep `<label>` as it is.
   - Keep `~` as it is.
   - Add support for `"`.
   - Add a prefix char equivalent to `m5_`. Say "\`"?
   - Add pragma that enables new behavior for unquoted text:
     - Auto-apply `m5_` prefixes.
     - Report an error for unquoted text.
     - Auto-quote numbers.
   - Also enable new behavior once a `"` is encountered.

   Incremental step toward non-M4 solution:
   - Keep M4 as the back-end, but write a new pre_m4 (by a new name) in Python(?) that produces compatible M4 output.
   - Enter quoted context by default. (Not required to re-enter to end file.)
   - Auto-apply `m5_`.
   - Let `m5_eval` retain its old behavior.
   - Write a new pre_m4 in Python (or stick w/ Perl, but... nah).
   - Need to convert current .m5 files.
   
   Clean rewrite:
   - Start from Python parser above.
   - Implement macro calls
     - Assign builtins for accessing args.
   - Implement builtin macros:
     - macro behind `var`/`macro`
     - math
     - regex
     - string manipulation
     - etc. (similar to M4 builtins)
   - Add position tracking and call stacks.


   ==== M6 (Work this in above)

   M6 would be rebuilt from scratch without the use of M4.
   - m6() has 0 args; m6(['']) has 1 arg; m6(m6_shift(1)) has 0 args.
   - No $ substitution if no arg list. In fact definitions should be distinct between vars and macros, so
   it's always one use or the other.
   - No @*
   - `m6_` and quote chars are configurable as an attribute of quoted text or file as a whole. (If still M4 under the hood, `pre_m6`
   would substitute it for a control character prefix, and M4 would be configured to recognize
   this control character as a word.)
   - No inline behavior of macros (`['']`) implied after macro definitions.
   - Many of the M4 macros that return unquoted text would return quoted text, and other <<Limitations_of_Tilde>>
   would be fixed as well.
   - All m6_... are interpreted as a call; error reported if macro doesn't exist.
   - Source tracking:
     - The macro (not just function) call stack can be maintained. The text produced by each macro can
     be associated with the macro call that produced it (in a nested fashion). (And each called macro can
     have an associate source location.)
     - M6 can maintain source tracking on all strings, identifying its position in the source file. This is
     the leaf level of the previous bullet.
     - This can lead to very useful interactive debug IDE features that associate output with source.
   - A debugger would be awesome. Within the debugger, all strings would have associated source/stack
   information.
   - To assist with (language-dependent) source tracking, provide a hook responsible for echoing each
   outputted piece of atomic text that is given its source line number, the number of lines (carriage
   returns) in the text (or end line number), and the call stack, as well as those of the previous text.


   === A Quick Taste
   This is a bit overstated. So we get rid of ternary vs. if. Big whoop.

   ...

   The same conditional macros can be applied to output text, strings, statements, and expressions, so there is less
   syntax and fewer keywords to learn. Here we use the `if` (also referenced as <<m_if>>) macro in various contexts and compare
   with a more traditional programming language syntax. `if`

   Inline conditional text:

    There are m5_if(m5_BallCnt < 0, ['no'], ['m5_BallCnt']) balls remaining.
   
    print("There are " + ((ball_cnt < 0) ? "no" : ball_cnt) + "balls remaining.");

   As a code statement producing output text:

    ~if(m5_BallCnt < 0, ['no'], ['m5_BallCnt'])

    print((ball_cnt < 0) ? "no" : ball_cnt);
   
   or
   
    out_str = out_str + ((ball_cnt < 0) ? "no" : ball_cnt);

   As conditional execution:

    if(m5_BallCnt < 0, [
       set(BallCnt, 0)
    ])
   
    if (ball_cnt < 0) {
       ball_cnt = 0;
    }

   As a conditional assignment:

    ~set(BallCnt, m5_if(m5_BallCnt < 0, ['0'], ['m5_BallCnt']))
   
    ball_cnt = (ball_cnt < 0) ? 0 : ball_cnt;

   ...
   **/


   [[usage]]
   == Getting Started with the Tilde Tool

   [[config]]
   === Configuring Tilde

   Tilde adds a minimal amount of syntax, and it is important that this syntax is unlikely to conflict
   with the target language syntax. The syntax that could conflict is listed in <<Ensure No Impact>>.
   Currently, there is no easy mechanisms to configure this syntax.


   === Running Tilde

   The Linux command:

   ```sh
   tilde in-file > out-file
   ```

   runs Tilde in its default configuration.

   /// TODO:
   (Currently, there's a dependency on M4 and perl and no installation script.)

   /// Describe use of a magic number.
   

   === Ensure No Impact

   When enabling the use of Tilde on a file, first, be sure Tilde processing does nothing to the file.
   Tilde should output the input text, unaltered, as long as your file contains no:

   - `<">~`


   === Tool Flow

   Since Tilde is simply substituting text, you can do bizarre things, which can be difficult to debug.
   Understanding the tool flow can help you look one step under the hood to debug issues or understand
   how syntax is interpreted.

   Tilde basically processes files in two steps:

   - Interpret syntactic sugar.
   - Run M4.

   (There is a third step as well that is very minor to undo some of the sugaring.)

   Object files are generated (run `tilde -h` for options) that expose the interpretation of Tilde sugar.
   Note that quotes and commas are substituted with control characters in these files, so you will
   need an appropriate tool to view them. Your shell may recognize them as binary files and prompt you
   about viewing them, which is fine to do.



   == Reading Tilde Code

   === A Quick Overview by Example

   The following example gives a general view of typical Tilde code and provides context for describing
   its language features. This example defines a "macro" called `withdraw` that updates a `Balance` variable
   (referenced as `$Balance`) and returns text describing the transaction. It should be fairly readable
   even without knowledge of Tilde syntax.

    # Withdraw credits from $Balance.
    # Args:
    #   Amount: The number of credits to withdraw.
    # Side Effects:
    #   Updates $Balance.
    # Output:
    #   Text describing the transaction.
    #   E.g.:
    #     Withdrawing 40.
    #     Starting balance: 100.
    #     New balance: 60.
    macro(withdraw, Amount, {
       # Report the transaction and balance.
       "Withdrawing " $Amount "." |     # Note: "|" produces a newline.
       "Starting balance: " $Balance "." |
       if([$Balance >= $Amount], {
          # Make/report the withdrawal.
          decrement(Balance, $Amount)
          "New balance: " $Balance "." |
       }, {
          # No withdrawal.
          "Insufficient balance." |
       })
    })
   
   /**
   The following is a simple form letter in Tilde:

    <">~  # Exit literal text.
    # Get the payment amount from a file.
    set(Amount, {include("payments/" $Name)})
    # Back to literal text.
    <">~
    Dear <">~$Name<">~,

    Thank you for your recent payment of <">~$Amount<">~. We appreciate your business.

    Sincerely,
    Acme Corporation
   **/

   This macro is called below:

    var(Balance, 100)   # Declare variable $Balance with value 100.
    withdraw(40)        # Withdraw 40 from $Balance.
   
   and produces the text:

    Withdrawing 40.
    Starting balance: 100.
    New balance: 60.

   Macro arguments are supplied as "code"--a sequence of "statements", with optional whitespace
   separation, where statements may be:

   - Literal strings, e.g. `"Withdrawing "` and `Balance`
   - Variable instantiations, e.g. `$Amount`
   - Arithmetic expressions: e.g. `[Balance >= $Amount]`
   - Macros calls: e.g. `var(Balance, 100)`
   - Special syntax: e.g. `|` for newline
   - Code blocks: i.e. `{...}`

   Aside from code blocks, each of these produces (possibly empty) text, and the result of evaluating the code
   is the concatenation of this text.

   A macro argument can be as simple as a literal string or as complex as
   a function body. For example, the code above calls `macro` with three arguments as `macro(withdraw, Amount, {...})`. The first
   two arguments are unquoted strings (aka "tokens"), and the third is the entire body of the `withdraw`
   macro.
   
   When calling a macro, the code of each argument is evaluated, and the resulting strings are passed
   into the parameters. For an argument that is enclosed in `{`/`}`, the parameter becomes the code itself,
   and this code may be evaluated later. The arguments to the `if` macro call above, for example, include
   two code arguments, and the `if` macro evaluates one of them.
   
   The remainder of this section describes these language features in greater detail using their default
   syntax. Note that some syntax is configurable. See <<Syntax Configuration>>.


   === Literal Strings

   ==== Quoted Literal Strings

   There are two syntaxes for quoted literal strings:

   - `+"+`/`+"+`: Light quotes. These are used for literal text strings.
   - `<">~`/`<">~`: Heavy quotes. These are also used for literal text strings and are
   generally used for larger, often multiline text.

   Heavily quoted strings differ from lightly quoted strings only in the quote characters used.
   Heavy quotes reduce the likelihood of conflicts with end quote characters in the strings.
   
   The only characters with special (non-literal) meaning within the string are the corresponding end
   quote characters. If the end quote characters are needed literally in the string, they can be followed
   by a `~` character. The `~` will be dropped and the string will continue until a non-literal
   end quote is encountered. Thus:

    "Say, "~Cheese"~!"

   represents the string: `Say, "Cheese"!`. Alternatively, heavy quotes can be used to avoid
   the need for the literal (`~`) character:

    <">~Say, "~Cheese"!<">~
   
   NOTE: Most languages use an escape character that precedes, not follows, the character to be escaped.
   Such a prefix escape character would itself need to have an escape sequence. Using a postfix character
   avoids this need. Other escape scenarios are handled in Tilde by ending the string and
   starting a new one later, which is concatenated, e.g.: `"Hi, "$Name"!"`.

   ==== Unquoted Literal Characters

   Argument characters that have no special meaning may pass through to a macro parameter literally.

   For example:

    var(Player.1.Score, 0)

   is equivalent to:

    var("Player.1.Score", "0")

   For details on which characters are permitted without quotes, see <<Unquoted Character Restrictions>>.

   ==== Multiline Strings

   Multiline strings begin with light or heavy quotes (`"` or `<">~`) that are followed immediately by a newline.
   The string is indented beneath the line containing the begin quote. It is terminated by
   the corresponding close quote beginning a line at the same level of indentation as the line on which
   the string began. The string's indentation, as well as the initial and final newline are excluded from
   the string. For example:

    set(MyPythonCode, <">~
      def foo():
        print("Hello, world!")
    <">~)
   
   The indentation is determined by the first non-whitespace character of the string.
   To enable multiline strings that begin with whitespace, a line containing only `v`
   can be used to point to the first character of the string. For example:

      set(MyPythonCode, <">~
        v
          def foo():
            print("Hello, world!")
      <">~)

   Defines a similar string with two spaces of indentation.

   === Arithmetic Expressions

   Arithmetic expressions can be provided within `[`/`]` and cannot be immediately preceded
   by word characters.

   For example:

    var(Val, [1 + 2 * 3])
    $Val    # Yields: "7"
   
   `[1 + 2 * 3]` is essentially shorthand syntax for `calc(1+2*3)`. (See <<m_calc>>.)
   
   Like other macro argument text, the text of the expression is code that evaluates to a string.
   The string, in this case, must be a valid expression as defined by <<m_calc>>. The example below
   illustrates that expressions may contain subexpressions, variable instantiations, macro calls,
   and unquoted characters.

      var(Val, [[$Val + 1] * if($Negate, -1, 1)])

   The set of characters that may be unquoted is different for expressions than for macro arguments.
   (See <<Argument Text>>.)


   [[variables]]
   === Variables

   Variables are name/value pairs where each may be an arbitrary string. Values may also be
   code. (See <<Code>>.)
   
   Variables are global, though each can hold a stack of values, with the top value being
   active. These stacks are used to provide scoped variables.

   Tilde does not specifically support data structures, but these can be implemented by libraries.
   For example, the variable `Player.1.Score` might represent a field `Score` of entry `1` of
   the `Player` array.

   Variables are defined (or pushed to their stack) using: <<m_var>>, are reassigned using <<m_set>>,
   and are accessed using <<m_get>>. For example:

    var(Foo, 5)
    increment(Foo)
    get(Foo)   /// Yields: "6"

   The syntax `$Foo` is shorthand for `get(Foo)`. Thus:

    $Foo   /// Yields: "6"


   === Macro Calls

   The following illustrates a call of the macro named `foo`:

    foo(hello, 5)

   A well-formed macro name is comprised of one or more word characters
   (`a-z`, `A-Z`, `0-9`, and `_`). Though discouraged, it is possible to define macros with names containing non-word characters.
   Such macros can only be called indirectly, e.g. `call("b@d", args)`. (See <<m_call>>.)

   The text string for an argument, between `(`, `,`, and/or `)`, is code or a code block. (See <<Code>>.)

   Empty argument text, as in `foo(, )`, is not permitted. Empty argument values are typically provided as `""`,
   thus `foo("", "")` is legal syntax. `foo()` represents a zero-argument call, not a call with a single empty argument.


   === Code Blocks

   Code blocks are code enclosed in `{`/`}`. They capture code for future evaluation.

   A code block can be evaluated (to a string) using the <<m_eval>> macro. For example:

    eval({set(Foo, 5)})

   Has the same effect as:

    set(Foo, 5)
   
   The <<m_if>> macro, below, has a first argument that is a condition and second
   and third arguments that may be evaluated (using <<m_eval>>) depending on the value
   of the condition. For example:

    if($Okay, {doit()}, {error("Bad.")})

   If <<m_eval>> is given a string rather than a code block, it simply returns the string.
   Thus a macro argument that is to be evaluated as code may generally also be given without `{`/`}`
   to pre-evaluate the code. For example:

    DEBUG("BoolVar is " if($BoolVar, {"true"}, {"false"}) ".")
   
   can be simplified to:

    DEBUG("BoolVar is " if($BoolVar, "true", "false") ".")

   Generally, as above, a macro argument will either be a single code block or statements producing strings.
   There are, however, no restrictions on mixing code blocks and other statements. An argument can contain
   a mix of pre-evaluated strings and code blocks. Consider the following example, which iterates over
   items, listing each one with leading text:

    repeat($NumItems, {$Indentation ": " GetItem($LoopCnt)})

   The first argument of the `repeat` macro is the number of iterations. The second is code to evaluate for each
   iteration. `$LoopCnt` is implicitly defined by `repeat` as the loop index. In this example, `$Indentation ": "` is
   the same for every iteration and can be pre-evaluated. We can achieve this as:

    repeat($NumItems, {} $Indentation ": " {GetItem($LoopCnt)})    # TODO: Is {} needed to coerce here or will coercion necessarily happen later anyway.
    repeat($NumItems, {:$Indentation ": " GetItem($LoopCnt)})      # Or, code block have to be a complete argument?
   
   TODO: Macro has everything a function has except scope for the body. That includes aftermath and
         push/pop of parameters (popped before aftermath). Function in not
         built-in and adds scope to the body. Code block is a macro with zero args.
   Nope: Calls push/pop $1... Functions add scope and push/pop params and are built-in so $1... can
         be assigned to ... args only. Code blocks are functions with no parameters (so there
         can be no push/pop of $1... and no scope). Use foo() or eval(foo) to evaluate code blocks??
   Nope: Macros are not built-in. Functions/code blocks are special built-in stacked variables and have text representations
         of their bodies accessible via body_of(...). (Functions are scoped; code blocks are not.)
         {} are code quotes.
         (They can be passed as code parameters as {foo()} (deferred) or get_code(foo).)
         Macros are a library function that modifies the code to replace $1, etc.
   TODO: Returning unquoted (inline) text to be evaluated, such as arg lists? Looks like I got rid of that in M5?
         Maybe comma should be allowed in a code block as an argument separator--no, too dangerous.

   === Declaring Macros

   Macros are in some respects, like variables. While variables can only be assigned to strings,
   macros are assigned to code. Unlike variables, macros take parameters. Though macros are
   rarely defined to be scoped, they can be and they have stacks, like variables.

   Macros declarations take the form:

    macro(<name>, [<param-list>,] {<body>})

   For example:

    macro(hello, Name, {"Hello, " $Name "!"})

   defines a macro named `Hello` that takes a parameter `Name`. This macro can be instantiated as:

    hello("Joe")
   
   resulting in the string: `Hello, Joe!`.


   === Special Code Syntax

   `|` is shorthand for <<m_nl>> and produces a newline.

   `~` is used to force preceding end quote characters to be taken literally and to continue a string.

   code(CallBarABC, {call(bar(a, b, c))})
   CallBarABC()  # bar(a, b, c)
   code_var(MyArgs, {, 1, 2, 3})   # Code may start with "," and, if it does, it may contain other top-level commas.
   args_code(MyArgs, 1, 2, 3)  # Equivalent to the above.
   append_code(MyArgs, {, 4})
   with_args({args_var(NewArgs, arg(1) args(3..))}, MyArgs)   # var(NewArgs, {, 1, 3, 4})
   args_var(MyArgs, ", 1, 2, 3")   # Must be empty or begin with ","; legal, balanced code delimited by ",".
                                   # Only code_snippet can take incomplete code arg.
   call(MyFn MyArgs())   # MyFn(1, 2, 3)
   code(CallFoo, to_code("call(foo" $MyArgs ")"))
   CallFoo()  # foo(1, 2, 3)
   call(arg(0), shift(2))   # args(3..) == shift(2)

   Somewhere... a code block that represents one or more arguments must begin with `,`. An empty code
   block may represent zero arguments.

   `@` begins a reference to zero or more numbered parameters. A reference to a negative number of
   parameters results in an error. Some syntaxes refer specifically to one parameter. These may
   appear anywhere in the code, thus they may contribute to part of an argument. Syntaxes which may
   refer to multiple parameters must produce a discrete number of arguments must be placed where
   an argument would be placed, preceded and followed by argument delimitation: `,`/`(` and `,`/`)`
   or in a code block which will begin with `,`. Though it appears as as an argument, it may result in
   zero arguments, where a preceding or following comma is ignored, or, if delimited by `(`/`)`, it
   may result in zero arguments.
   
   `@1` refers to the first unnamed parameter (which must exist), `@15` the 15th.

   `@2?` refers to the second unnamed parameter or "" if it doesn't exist.

   `@3..` refers to all arguments from the third, or none, in which case the preceding `,` is ignored.

   `@1..3` is equivalent to `@1, @2, @3`.

   `@1..3?` is equivalent to `@1?, @2?, @3?`.

   `@1..-1` is arguments @1 up to the one before the last.

   `@(...)` evaluates the parenthetical code and interprets the results as the text after `@` in cases above.

   `@foo(...)` evaluates the resulting code, which must begin with a comma argument separator or be empty.
   This comma will be ignored or an empty result represents zero arguments.

   `@#` is the number of arguments.


   === Functions

   Functions are macros that evaluate in their own scope.

    fn()

   === Functions

   All but the simplest of macros are most often declared using `m5_fn` and similar macros. These support a richer set of
   mechanisms for defining and passing parameter. While `m5_macro` is most often used with a one-line body definition,
   `m5_fn` is most often used with multi-line bodies as <<Scoped Code Blocks>>.

   Such `m5_fn` declarations using <<Scoped Code Blocks>> look and act like functions/procedures/subroutines/methods in a traditional
   programming language, and we often refer to them as "functions". Function calls pass arguments into parameters. Functions'
   code block bodies contain macro calls (statements) that define local variables, perform calculations, evaluate code conditionally,
   iterate in loops, call other functions, recurse, etc.

   Unlike typical programming languages, functions, like all macros, evaluate to text that substitutes for the calls.
   There is no mechanism to explicitly print to the standard output stream (though there
   are macros for printing to the standard error stream). Only a top-level call from the source code will
   implicitly echo to standard output.

   Functions are defined using: <<m_fn>> and <<m_lazy_fn>>.

   Declarations take the form:

    m5_fn(<name>, [<param-list>,] ['<body>'])

   A basic function declaration with a one-line body looks like:

    m5_fn(mul, val1, val2, ['m5_calc(m5_val1 * m5_val2)'])

   Or, equivalently, using a code block body:
      
    fn(mul, val1, val2, {
       ~calc(m5_val1 * m5_val2)
    })

   This `mul` function is called (in source context) like:

    m5_mul(3, 5)  //']['/ produces 15

   ==== Parameters

   ===== Parameters Types and Usage

   - *Numbered parameters*: Numbered parameters, as in <<m_macro>> (see <<Declaring Macros>>), can be referenced as `$1`, `$2`, etc. with
                            the same replacement behavior. However, they
                            are explicitly identified in the parameter list (see <<parameter_list>>).
                            Within the function body, similar to `['$3']`, <<m_fn_arg>> may also be used to access an argument. For example,
                            `m5_fn_arg(3)` evaluates to the literal third argument value.
   - *Special parameters*: As for <<m_macro>>, special parameters are supported. Note that: `${empty}@`, `${empty}*`, and `${empty}#` reflect only
                           numbered parameters. Also, `${empty}0` will not have the expected value, however `${empty}0__` can still be
                           used as a name prefix to localize names to this function. (See <<masking>>.) Similar to `${empty}@`, the <<m_fn_args>> macro
                           (or variable) also provides a quoted list of the numbered arguments.
                           Similar to `${empty}#`, the <<m_fn_arg_cnt>> macro also provides the number of numbered arguments.
   - *Named parameters*: These are available locally to the body as variables. They are not available to the <<Aftermath>> of
                         the function.

   [[parameter_list]]
   ===== The Parameter List

   The parameter list (`<param-list>`) is a list of zero or more `<param-spec>`{empty}s, where `<param-spec>` is:

   - A parameter specification of the form: `[?][[<number>]][[^]<name>][: <comment>]` (in this order), e.g. `?[2]^Name: the name of something`:
     * `<name>`:   Name of a named parameter.
     * `?`:        Specifies that the parameter is optional. Calls are checked to ensure that arguments are provided for all non-optional parameters
                   or are defined for inherited parameters. Non-optional parameters may
                   not follow optional ones.
     * `[<number>]`: Number of a numbered parameter. The first must be `[1]` and would correspond to `$1` and `m5_fn_arg(1)`, and so on.
                     `<number>` is verified to match the sequential ordering of numbered parameters. Numbered parameters may
                     also be named, in which case they can be accessed either way.
     * `^`:        Specifies that the parameter is inherited. It must also be named. Its definition is inherited from the context of the func definition.
                   If undefined, the empty `['']` value is provided and an error is reported unless the parameter is optional,
                   e.g. `?^<name>`. There is no corresponding argument in a call of this function. It is conventional to list
                   inherited parameters last (before the body) to maintain correspondence between the parameter
                   list of the definition and the argument list of a call.
     * `<comment>`: A description of the parameter. In addition to commenting the code, this can be extracted in
                   documentation./** See <<m_enable_doc>>.**/
   - `...`:        Listed after last numbered parameter to allow extra numbered arguments. Without this, extra arguments
                   result in an error (except for the single empty argument of e.g. `m5_foo()`. See <<fn_arguments>>.)

   ==== When To Use What Type of Parameter

   For nested declarations, the use of numbered parameters (`${empty}1`, `${empty}2`, ...) and special parameters
   (`${empty}@`, `${empty}*`, `${empty}#`, and `${empty}0`) can be extremely awkward.
   Nested declarations are declarations within the bodies of other declarations. Since nested bodies are part of outer bodies,
   numbered and special parameters within them would actually substitute based on the outer bodies. This can be prevented
   by generating the body with macros that produce the numbered parameter references, but this requires an unnatural and bug prone use of quotes.
   Therefore the use of functions with named parameters is preferred for inner macro declarations. Use of <<m_fn_args>> and <<m_fn_arg>> is
   also simpler than using special parameters. If parameters are named, these are helpful primarily
   to access `...` arguments or to pass argument lists to other functions.

   Additionally, and in summary:

   - *Numbered/special parameters*: These can be convenient to ensure substitution throughout the body without interference from
                        quotes. They can, however, be extremely awkward to use in nested definitions
                        as they would substitute with the arguments of the outer function/macro. Being unnamed,
                        readability is an issue, especially for large functions.
   - *Named parameters*: These act more like typical function arguments vs. text substitution. Since they are named, they
                        can improve readability. Unlike numbered parameters, they work perfectly well in functions
                        defined within other functions/macros. (Similarly, <<m_fn_args>> and <<m_fn_arg>> are useful
                        for nested declarations.) Macros will not evaluate within quoted strings, so typical use requires
                        unquoting, e.g. `['Arg1: ']m5_arg1['.']` vs. `['Arg1: $1.']`.
   - *Inherited parameters*: These provide a more natural, readable, and explicit mechanism for customizing a function to the
                        context in which it is defined. For example a function may define another function that is
                        customized to the parameters of the outer function.

   [[fn_arguments]]
   ==== Function Call Arguments

   Function calls must have arguments for all non-optional, non-inherited (`^`) parameters. Arguments are positional, so misaligning arguments
   is a common source of errors. There is checking, however, that required arguments are provided and that no extra arguments are given.
   `m5_foo()` is permitted for a function `foo` declared with no parameters, though it is passed one emtpy parameter.
   (`m5_call(foo)` might be preferred.)

   ==== Function Arguments Example

   In argument list context, function `foo` is declared below to display its parameters.

    /Context:
    var(Inherit2, two)
    /Define foo:
    fn(foo, Param1, ?[1]Param2: an optional parameter,
            ?^Inherit1, [2]^Inherit2, ..., {
       ~nl(Param1: m5_Param1)
       ~nl(Param2: m5_Param2)
       ~nl(Inherit1: m5_Inherit1)
       ~nl(Inherit2: m5_Inherit2)
       ~nl(['numbered args: $@'])
    })

   And it can be called (again, in argument list context):

    /Call foo:
    foo(arg1, arg2, extra1, extra2)

   And this expands to:

    Param1: arg1
    Param2: arg2
    Inherit1:
    Inherit2: two
    numbered args: ['arg2'],['two'],['extra1'],['extra2']

   ==== Aftermath

   It is possible for a function to make assignments (and, actually do anything) in the calling scope.
   This can be done using <<m_on_return>> or <<m_return_status>>.

   This is important for:

   - passing arguments by reference
   - returning status
   - evaluating body arguments
   - tail recursion

   Each of these is discussed in its own section, next.


   ==== Passing Arguments by Reference

   Functions can pass variables by reference and make assignments to the referenced
   variables upon returning from the function. For example:

    fn(update, FooRef, {
       var(Value, ['updated value'])
       on_return(set, m5_FooRef, m5_Value)
    }
    set(Foo, ['xxx'])
    update(Foo)
    ~Foo   /// Results in "updated value".

   A similar function could be defined to declare a referenced variable by using `var` instead of `set`.

   The use of <<m_on_return>> avoids the potential masking issue that would result from:

    update(Value)


   [[returning_status]]
   ==== Returning Status

   A function's <<v_status>> should be returned via the function's aftermath, using <<m_return_status>>, e.g.

    fn(my_fn, Val, {
       if(m5_Val > 10, [''])
       return_status(m5_status)   /// Return the status from the if statement.
    })

   Functions automatically restore <<v_status>> after body evaluation to its value prior to body evaluation, so
   the evaluation of the body has no impact on <<v_status>>. Aftermath is evaluated after this.
   It is fine to call <<m_return_status>> multiple times. Only the last call will have a visible effect.


   [[body_arguments]]
   ==== Functions with Body Arguments

   The example below illustrates a function `if_neg` that takes an argument that is a body to evaluate.
   The body is defined in a calling function, e.g. `my_fn` on lines 15-16. Such a body is expected to evaluate
   in the context of the calling function, `my_fn`. Its assignment of `Neg`, on line 15, should be an assignment of
   its own local `Neg`, declared on line 12. Its side effects from <<m_return_status>> on
   line 15 should be side effects of `my_fn`.

   If the body is evaluated inside the function body, its side effects would be side effects of `if_neg`,
   not `my_fn`. The body should instead be evaluated as aftermath, using <<m_on_return>>, as on line 6.

   Note that <<m_return_status>> is called after evaluating `m5_Body`. Both <<m_on_return>> and <<m_return_status>>
   add to the <<Aftermath>> of the function, and <<v_status>> must be set after evaluating the body (which
   could affect <<v_status>>).

   Example of a body argument.

     1: // Evaluate a body if a value is negative.
     2: fn(if_neg, Value, Body, {
     3:    var(Neg, m5_calc(Value < 0))
     4:    ~if(Neg, [
     5:       /~eval(m5_Body)    /// Incorrect!!!
     6:       on_return(Body)    /// Correct.
     7:    ])
     8:    return_status(if(Neg, [''], else))
     9: })
    10: 
    11: fn(my_fn, {
    12:    var(Neg, [''])
    13:    return_status(['pos'])
    14:    ~if_neg(1, [
    15:       return_status(['neg'])
    16:       set(Neg, ['-'])
    17:    ])
    18:    ...
    19: })

   Since <<m_macro>> does not support <<Aftermath>>, it is not recommended to use <<m_macro>> with a body argument.


   ==== Tail Recursion

   Recursive calls tend to grow the stack significantly, and this can result in an error (see <<v_recursion_limit>>) as well
   inefficiency. When recursion is the last act of the function ("tail recursion"), the recursion can be performed in
   aftermath to avoid growing the stack. For example:

    fn(my_fn, First, ..., {
       ...
       ~unless(m5_Done, [
          ...
          on_return(my_fn\m5_comma_args())
       ])
       ...
    })


   === Block Labels

   Code can be nested within several layers of code blocks. Generally, code evaluates sequentially within its
   block, but it can be useful to pre-evaluate code. Block labels provide convenient syntax for this.

   //Code can be evaluated prior to the evaluation of the block within which it is contained. Block labels are
   //used indicate the block that to a block of code so that it can be  pre-evaluate code within a code block. Code blocks can be labeled as, e.g.:

   // fn(foo, body:{
   //    ...
   // })
   
   In the simple example below, `h` is a label for the code block.

    code(hello, h:{
       "Hello, " h:$Name "." |
    })
   
   The label is used within the block as `h:$Name`, providing scope to the variable `$Name`.
   `h:$Name` takes on the value of `Name` outside of the block labeled `h`. It evaluates when the `h`
   block is parsed. The above is equivalent to:

    code(hello, {
       "Hello, "} $Name {"."
    })
   
   but the use of labels allows us to align `{`/`}` pairs more naturally (and legally, see <<xxx>>). Also,
   consider the modification without the use of a label:
   
    code(hello, {
       if($Cond, {
          "Hello, "} $Name {"."
       }
    })
   
   This modification would no longer evaluate `$Name` at the time of the code definition, whereas the
   labeled reference is more explicit and avoids this easy mistake. Note that the following would,
   in concept, fix this bug:

    code(hello, {
       if($Cond, {
          "Hello, "}} $Name {{"."
       }
    })
   
   though this is not permitted due to the apparent mismatching parentheses and for its lack of readability.
   (See <<xxx>>.) The correct code, using a label, is:

    code(hello, h:{
       "Hello, " h:$Name "."
    })

   Labels may be associated with calls (`label:foo()`) and variables (`label:$Foo`).

    label:foo(a1)          # Evaluates using the definition of `foo` at the time the labeled block is parsed.
    label:(foo(a1)...)     # Evaluates `call(foo, a1)...` at the time the labeled block is parsed. (Continue applying the label
                           # through the argument list.) Maybe, no. Just require `var(tmp, foo(a1)...)` outside, then `label:$tmp`??

   === String Labels

   String labels use a similar syntax to <<Block Labels>>, but they serve a different purpose. They
   have no impact functionally. Instead they are used to convey to an editor or IDE the syntax used in a
   multiline string. For example, if Tilde is being used to process Python code, the following might be
   used:

    set(MyPythonCode, python:<">~
      def foo():
        print("Hello, world!")
    <">~)
   
   An editor that recognizes the `python:` label might provide appropriate syntax highlighting for the
   Python code.

   === Syntax Configuration



   == Writing Tilde Code

   === Code Formatting

   === Unquoted Character Restrictions

   There are restrictions on the use of unquoted characters in arguments. This
   affords greater flexibility for syntax configuration. It also encourages quoting to
   avoid missing quotes around special characters.

   The restrictions are different for argument text and arithmetic expressions.

   ==== Unquoted Argument Characters

   Unquoted text is only permitted in argument text as a string of non-whitespace characters
   without other statements. This string of characters may be referred to as a "token".

   Tokens may include:
   
   - word characters: `a-z`, `A-Z`, `0-9`, `_`
   - some symbols: `~^&*-+.?`

   Tokens may not include:

   - whitespace
   - comma (`,`)
   - paired characters: `()[]{}<>`
   - quote characters: `"'\``
   - certain symbols that have other significance by default or that may be configured to have other significance:
   `!#@%=:;$/\\|`

   ==== Unquoted Arithmetic Expressions Characters

   In arithmetic expressions, unquoted characters are free to mingle with other
   statements.

   Permitted characters include:

   - whitespace (which is ignored and irrelevant to <<m_calc>>)
   - digits: `0-9`
   - symbols: `+-*/!=<>%&|`

   And these cannot be used as unquoted literal characters:

   - word characters: `a-z`, `A-Z`, `_`
   - paired characters: `()[]{}`
   - quote characters: `"'\``
   - symbols: `~$#@^:;\\.?`

   `|` is not treated as a newline character in arithmetic expressions.


   === Constructing Code
   
   Though rarely needed, code may be constructed from strings and converted to code using the `compile` macro.
   For example this modifies the above example to call either `error`, `warning`, or `info` based on the
   value of `ErrorLevel` which holds one of those three strings. (Note, there are other ways
   to accomplish this.):
   
    var(ErrorLevel, "error")  # or "warning" or "info"
    ...
    var(BadCodeString, $ErrorLevel <">("Ugh!")<">)
        # E.g. <">error("Ugh!")<">
    var(BadCode, compile($BadCodeString))
        # E.g. {error("Ugh!")}
    if($Okay, {doit()}, $BadCode)

   Code blocks can most directly be evaluated using the `eval` macro. For example:

    eval($BadCode)   # Reports "Ugh!".



   == Standard Library Reference









   /** WIP
   === Contexts: Namespaces, and Libraries

   ==== Contexts

   The context of a macro comes in three types:

   - Universal: Universal macro names are the same for any Tilde program. These can be called directly, prefixed
   with `m5_`. They can be:
   - Built-in: These are defined by the Tilde library.
   - External: These are only defined if explicitly included.
   - Namespaced: Namespaces are used to avoid name conflicts between third-party libraries and between different
   versions of the same library. Namespaces are local to a library or application, and may exist in a hierarchy.
   The same macro may exist in multiple namespaces of multiple libraries, and its definition is shared.
   Namespaced macros are called via `m5_my(...)`.
   - Scoped: Declarations made within a <<scope>> are local to that scope. Naming conventions avoid
   name conflicts with the other context types.


   ==== Macro Naming Conventions

   To avoid <<masking>> issues, naming conventions divide the namespace in two styles:

   - Lower case with underscores, e.g.: `m5_builtin_macro`
   - Pascal case, e.g. `m5_MyVarName`

   Names using lowercase with underscores: universal, namespaces, namespaced

   Names using Pascal case: scoped macros (variables, functions, and traditional macros)

   In both cases, names must be composed of ASCII characters `A-Z`, `a-z`, `0-9`, and `_`, and the first character must be alphabetic.

   Libraries may define private macros using double underscore (`__`). A non-private macro in a universal library reserves
   its own name in the universal namespace and also private names beginning with that name and `__`.
   To maximize the ability of third-party libraries to share a namespace with other libraries, macros in third-party
   libraries that are helpers for other macros should use the name of the associated macro before the `__`.


   ==== Universal Macros

   ==== Namespaces

   ==== Libraries

   **/

   === Coding Paradigms, Patterns, Tips, Tricks, and Gotchas
   [[masking]]
   ==== Variable Masking

   Variable "masking" is an issue that can arise when a macro has side effects determined by its arguments.
   For example, an argument might specify the name of a variable to assign, or an argument might provide a body to
   evaluate that could declare or assign arbitrary variables. If the macro declares a local variable,
   and the side effect updates a variable by the same name, the local variable may inadvertently be the
   one that is updated by the side effect. This issue is addressed differently depending
   how the macro is defined. Note that using function <<Aftermath>> is the preferred method, but all
   options are listed here for completeness:

   * Functions: Set variables using <<Aftermath>>. Using functions for variable-setting macros is preferred.
   * Macros declaring their body using a code block: Set variable using <<m_out_eval>>.
   * Macros declaring their body using a string: Push/pop local variables named using `${empty}0__` prefix.
<">)


m5_do([
   enable_doc(adoc)

   /Shorthand for m5_doc_macro__adoc__fn__<name>.
   macro(DocFn, {nl()doc_as_fn($@)get(doc_macro__adoc__fn__$1)nl()})
   macro(DocFns, {nl()doc_now_as_fns($@)}nl())
   macro(DocVar, nl()defn(doc_macro__doc_var)nl())

   var(mac_spec, *[
      ~(<">
      
         == Macro Library

         This section documents the macros defined by the Tilde 1.0 library. Some macros documented here are
         necessary to enable inclusion of this library and are, by necessity, built-into the language. This
         distinction may not be documented.
      
         === Specification Conventions
      
         Macros are listed by category in a logical order. An alphabetical <<Index>> of macros can be found at the end of
         this document (at least in the `.pdf` version).
         Macros that return integer values, unless otherwise specified, return decimal value strings. Similarly,
         macro arguments that are integer values accept decimal value strings. Boolean inputs and outputs use
         `0` and `1`. Behavior for other argument values is undefined if unspecified.
         
         Resulting output text is, by default, literal (quoted). Macros named with a `_eval` suffix generally result
         in text that gets evaluated.
      
         === Assigning and Accessing Macros/Variables

         ==== Declaring/Setting Variables

      <">)
      
      ~DocFn(var, <">
         D: Declare a scoped variable. See <<variables>>.
         S: the variable is defined
         E: var(Foo, 5)
         A: (m_macro, m_fn)
      <">, Name: variable name, ?Value: the value for the variable, ...: additional variables and values to declare (values are required))
      
      ~DocFn(set, <">
         D: Set the value of a scoped variable. See <<variables>>.
         S: the variable's value is set
         E: set(Foo, 5)
         A: (m_var)
      <">, Name: variable name, Value: the value)
      
      ~DocFn(push_var, <">
         D: Declare a variable that must be explicitly popped.
         S: the variable is defined
         E: push_var(Foo, 5)
         ...
         pop(Foo)
         A: (m_pop)
      <">, Name: variable name, Value: the value)
      
      ~DocFn(pop, <">
         D: Pop a variable or traditional macro declared using `push_var` or `push_macro`.
         S: the macro is popped
         E: push_var(Foo, 5)
         ...
         pop(Foo)
         A: (m_push_var, m_push_macro)
      <">, Name: variable name)
      
      ~DocFn(null_vars, <">
         D: Declare variables with empty values.
         S: the variables are declared
      <">, ...: names of variables to declare)
      ~("
      
         ==== Declaring Macros
      
      ")
      ~DocFns(['fn, lazy_fn'], <">
         D: Declare a function. For details, see <<Functions>>. `fn` and `lazy_fn` are functionally equivalent but
         have different performance profiles, and lazy functions do not support inherited (`^`) parameters.
         Lazy functions wait until they are used before defining themselves, so they are generally preferred
         in libraries except for the most commonly-used functions.
         S: the function is declared
         E: fn(add, Addend1, Addend2, {
            ~calc(Addend1 + Addend2)
         })
         A: (Functions)
      <">, ...: arguments and body)


      /**
      ~DocFn(, <">
         D: 
         O: 
         S: none
         E: 
         P: 
         A: ()
      <">, ...: )
      **/
      
      ~DocFns(['macro, null_macro'], <">
         D: Declare a scoped macro. See <<Declaring Macros>>. A null macro must produce no output.
         S: the macro is declared
         E: m5_macro(ParseError, <p>[
            error(['Failed to parse $<p>1.'])
         ])
         A: (m_var, m_set_macro)
      <">, Name: the macro name, Body: the body of the macro)
      
      ~DocFn(set_macro, <">
         D: Set the value of a scoped(?) macro. See <<Declaring Macros>>. Using this macro is rare.
         S: the macro value is set
         A: (m_var, m_set_macro)
      <">, Name: the macro name, Body: the body of the macro)
      
      ~DocFn(push_macro, <">
         D: Push a new value of a macro that must be explicitly popped. Using this macro is rare.
         S: the macro value is pushed
         A: (m_pop, m_macro, m_set_macro)
      <">, Name: the macro name, Body: the body of the macro)
      ~("

         ==== Accessing Macro/Variable Values
      
      ")
      ~DocFn(get, <">
         O: the value of a variable without `$` substitution (even if not assigned as a string)
         E: var(OneDollar, ['$1.00'])
         get(OneDollar)
         P: 
         $1.00
         A: (m_var, m_set)
      <">, Name: name of the variable)
      
      ~DocFns(['must_exist, var_must_exist'], <">
         D: Ensure that the `Name`d macro (`must_exist`) or variable (`var_must_exist`) exists.
      <">, Name: name of the macro/variable)
      ~("
      
         === Code Constructs
      
         ==== Status

      ")
      ~DocVar(status, <">
         D: This universal variable is set as a side-effect of some macros to indicate an exceptional
         condition or non-evaluation of a body argument. It may be desirable to check this condition
         after calling such macros. Macros, like `m5_else` take action based on the value
         of `m5_status`. An empty value indicates no special condition.
         Macros either always set it (to an empty or non-empty value) or never set it. Those that set
         it list this in their "Side Effect(s)".
         A: (m_fn, m_return_status, m_else, m_sticky_status)
      <">)
      
      ~DocVar(sticky_status, <">
         D: Used by the <<m_sticky_status>> macro to capture the value of `m5_status`.
         A: (v_status, m_sticky_status)
      <">)
      
      ~DocFn(sticky_status, <">
         D: Used to capture the first non-empty status of multiple macro calls.
         S: <<v_sticky_status>> is set to <<v_status>> if it is empty and <<v_status>> is not.
         E: if(m5_A >= m5_Min, [''])
         sticky_status()
         if(m5_A <= m5_Max, [''])
         sticky_status()
         if(m5_reset_sticky_status(), ['m5_error(m5_A is out of range.)'])
         A: (v_status, m_sticky_status, m_reset_sticky_status)
      <">)
      
      ~DocFn(reset_sticky_status, <">
         D: Tests and resets <<v_sticky_status>>.
         O: [`0` / `1`] the original nullness of <<v_sticky_status>>
         S: <<v_sticky_status>> is reset (emptied/nullified)
         A: (m_sticky_status)
      <">)
      ~("

         ==== Conditionals

      ")
      doc_as_fn(unless, "", Cond, TrueBody, FalseBody)
      ~DocFns(['if, unless, else_if'], <">
         D: An if/else construct. The condition is an expression that evaluates using <<m_calc>> (generally boolean (0/1)).
         The first block is evaluated if the condition is non-0 (for `if` and `else_if`) or 0 (for `unless`),
         otherwise, subsequent conditions are evaluated, or if only one argument remains, it is the
         final else block, and it is evaluate. (`unless` cannot have subsequent conditions.) `if_else` does
         nothing if `m5_status` is initially empty.
         
         NOTE: As an alternative to providing else blocks within `m5_if`, <<m_else>> and similar macros may be used subsequent to
         `m5_if` / `m5_unless` and other macros producing <<v_status>>, and this may be easier to read.
         O: the output of the evaluated body
         S: status is set, empty iff a block was evaluated; side-effects of the evaluated body
         E: ~if(m5_eq(m5_Ten, 10) && m5_Val > 3, [
            ~do_something(...)
         ], m5_Val > m5_Ten, [
            ~do_something_else(...)
         ], [
            ~default_case(...)
         ])
         A: (m_else, m_case, m_calc)
      <">, Cond: ['the condition expression, evaluated as for `m5_\calc`'],
         TrueBody: ['the body to evaluate if the condition evaluates to true (1)'],
         ...: ['either a `FalseBody` or (for `m5_\if` only) recursive `Cond`, `TrueBody`, `...` arguments to evaluate if the condition evaluates to false (not 1)'])
      
      ~DocFns(['if_eq, if_neq'], <">
         D: An if/else construct where each condition is a comparison of an independent pair of strings.
         The first block is evaluated if the strings match (for `if`) or mismatch (for `if_neq`), otherwise, the
         remaining arguments are processed in a recursive call, either comparing the next pair of strings
         or, if only one argument remains, evaluating it as the final else block.
            
         NOTE: As an alternative to providing else blocks, <<m_else>> and similar macros may be used subsequently,
         and this may be easier to read.
         O: the output of the evaluated body
         S: status is set, empty iff a body was evaluated; side-effects of the evaluated body
         E: ~if_eq(m5_Zero, 0, [
            ~zero_is_zero(...)
         ], m5_calc(m5_Zero < 0), 1, [
            ~zero_is_negative(...)
         ], [
            ~zero_is_positive(...)
         ])
         A: (m_else, m_case)
      <">, String1: the first string to compare,
         String2: the second string to compare,
         TrueBody: the body to evaluate if the strings match,
         ...: ['either a `FalseBody` or recursive `String1`, `String2`, `TrueBody`, `...` arguments to evaluate if the strings do not match'])
      
      doc_as_fn(if_null, [''], Var, Body, ?ElseBody)
      doc_as_fn(if_var_def, [''], Var, Body, ?ElseBody)
      doc_as_fn(if_var_ndef, [''], Var, Body, ?ElseBody)
      ~DocFns(['if_null, if_var_def, if_var_ndef, if_defined_as'], <">
         D: Evaluate `Body` if the named variable is empty (`if_null`), defined (`if_var_def`), not defined (`if_var_ndef`), or not defined and equal to the given value (`if_defined_as`).,
         or `ElseBody` otherwise.
         O: the output of the evaluated body
         S: status is set, empty iff a body was evaluated; side-effects of the evaluated body
         E: if_null(Tag, [
            error(No tag.)
         ])
         A: (m_if)
      <">, Var: the variable's name,
         Value: ['for `if_defined_as` only, the value to compare against'],
         Body: ['the body to evaluate based on `m5_\Name`'s existence or definition'],
         ?ElseBody: a body to evaluate if the condition if `Body` is not evaluated)
      
      ~DocFns(['else, if_so'], <">
         D: Likely following a macro that sets `m5_status`, this evaluates a body if <<v_status>> is non-empty (for `else`) or empty (for `if_so`).
         O: the output of the evaluated body
         S: status is set, empty iff a body was evaluated; side-effects of the evaluated body
         E: ~if(m5_Cnt > 0, [
            decrement(Cnt)
         ])
         else([
            ~(Done)
         ])
         A: (m_if, m_if_eq, m_if_neq, m_if_null, m_if_def, m_if_ndef, m_var_regex)
      <">, Body: ['the body to evaluate based on <<v_status>>'])
      
      ~DocFn(else_if_def, <">
         D: Evaluate `Body` iff the `Name`d variable is defined.
         O: the output of the evaluated body
         S: status is set, empty iff a body was evaluated; side-effects of the evaluated body
         E: m5_set(Either, if_var_def(First, m5_First)m5_else_if_def(Second, m5_Second))
         A: (m_else_if, m_if_def)
      <">, Name: the name of the case variable whose value to compare against all cases,
         Body: ['the body to evaluate based on <<v_status>>'])
      
      ~DocFn(case, <">
         D: Similar to <<m_if>>, but each condition is a string comparison against a value in the `Name` variable.
         O: the output of the evaluated body
         S: status is set, empty iff a block was evaluated; side-effects of the evaluated body
         E: ~case(Response, ok, [
            ~ok_response(...)
         ], bad, [
            ~bad_response(...)
         ], [
            error(Unrecognized response: m5_Response)
         ])
         A: (m_else, m_case)
      <">, Name: the name of the case variable whose value to compare against all cases,
         Value: the first string value to compare `VarName` against,
         TrueBody: the body to evaluate if the strings match,
         ...: ['either a `FalseBody` or recursive `Value`, `TrueBody`, `...` arguments to evaluate if the strings do not match'])
      ~("

         ==== Loops
      
      ")
      ~DocFn(loop, <">
         D: A generalized loop construct. Implicit variable `m5_LoopCnt` starts at 0 and increments by 1
         with each iteration (after both blocks).
         O: output of the blocks
         S: side-effects of the blocks
         E: ~loop((MyVar, 0), [
            ~do_stuff(...)
         ], m5_LoopCnt < 10, [
            ~do_more_stuff(...)
         ])
         A: (m_repeat, m_for, m_calc)
      <">, InitList: ['a parenthesized list, e.g. `(Foo, 5, Bar, ok)` of at least one variable, initial-value pair providing variables scoped to the loop, or `['']`'],
         DoBody: ['a block to evaluate before evaluating `WhileCond`'],
         WhileCond: ['an expression (evaluated with <<m_calc>>) that determines whether to continue the loop'],
         ?WhileBody: ['a block to evaluate if `WhileCond` evaluates to true (1)'])
      
      ~DocFn(repeat, <">
         D: Evaluate a block a predetermined number of times. Implicit variable `m5_LoopCnt` starts at 0
         and increments by 1 with each iteration.
         O: output of the block
         S: side-effects of the block
         E: ~repeat(10, [
            ~do_stuff(...)
         ])  //{empty}/ Iterates m5_LoopCnt 0..9.
         A: (m_loop)
      <">, Cnt: ['the number of times to evaluate the body'],
         Body: ['a block to evaluate `Cnt` times'])
      
      ~DocFn(for, <">
         D: Evaluate a block for each item in a listed. Implicit variable `m5_LoopCnt` starts at 0
         and increments by 1 with each iteration.
         O: output of the block
         S: side-effects of the block
         E: ~for(fruit, ['apple, orange, '], [
            ~do_stuff(...)
         ])  //{empty}/ (also maintains m5_LoopCnt)
         A: (m_loop)
      <">, Var: ['the loop item variable'],
         List: ['a list of items to iterate over, the last of which will be skipped if empty; for each item, `Var` is set to the item, and `Body` is evaluated'],
         Body: ['a block to evaluate for each item'])
      ~("

         ==== Recursion
      
      ")
      ~DocFn(recurse, <">
         D: Call a macro recursively to a given maximum recursion depth. Functions have a built-in recursion
         limit, so this is only useful for macros.
         O: the output of the recursive call
         S: the side effects of the recursive call
         E: m5_recurse(20, myself, args)
         A: (v_recursion_limit, m_on_return)
      <">, max_depth: the limit on the depth of recursive calls made through this macro, macro: the recursive macro to call, ...: arguments for `macro`)
      ~("

         === Working with Strings
      
         ==== Special Characters
      
      ")
      ~DocFn(nl, <">
         D: Produce a new-line. Programmatically-generated output should always use this macro
         (directly or indirectly) to produce new-lines, rather than using an actual new-line in
         the source file. Thus the input file formatting can reflect the code structure, not the output
         formatting. 
         O: a new-line
      <">)
      
      ~DocFns(['open_quote, close_quote'], <">
         D: Produce an open or close quote. These should rarely (never?) be needed and should be used with extra
         caution since they can create undetected imbalanced quoting. The resulting quote is literal,
         but it will be interpreted as a quote if evaluated.
         O: the literal quote
         A: (m_quote)
      <">)
      
      ~DocVar(arg_comma, <">
         O: A macro argument separator comma.
         A: (Literal Commas)
      <">)
      
      ~DocFns(['orig_open_quote, orig_close_quote'], <">
         D: Produce `['` or `']`. These quotes in the original file are translated internally to ASCII
         control characters, and in output (STDOUT and STDERR) these control characters are translated to single-unicode-character
         "printable quotes". This original quote syntax is most easily produced using these macros, and
         once produced, has no special meaning in strings (though `[` and `]` have special meaning in
         regular expressions).
         O: the literal quote
         A: (m_printable_open_quote, m_printable_close_quote)
      <">)
      
      ~DocFns(['printable_open_quote, printable_close_quote'], <">
         D: Produce the single unicode character used to represent `['` or `']` in output (STDOUT and STDERR).
         O: the printable quote
         A: (m_orig_open_quote, m_orig_close_quote)
      <">)
      
      ~DocFn(['UNDEFINED'], <">
         D: A unique untypeable value indicating that no assignment has been made.
         This is not used by any standard macro, but is available for explicit use.
         O: the value indicating "undefined"
         E: m5_var(Foo, m5_UNDEFINED)
         m5_if_eq(Foo, m5_UNDEFINED, ['['Foo is undefined.']'])
         R: Foo is undefined.
      <">)
      ~("

         ==== Slicing and Dicing Strings

      ")
      ~DocFns(['append_var, prepend_var, append_macro, prepend_macro'], <">
         D: Append or prepend to a variable or macro. (A macro evaluates its context; a variable does not.)
         E: m5_var(Hi, ['Hello'])
         m5_append_var([', ']m5_Name['!'])
         m5_Hi
         P: Hello, Joe!
      <">, Name: the variable name, String: the string to append/prepend)
      
      ~DocFns(['substr, substr_eval'], <">
         D: Extract a substring from `String` starting from `Index` and extending for `Length` ASCII characters (unicode bytes)
         or to the end of the
         string if `Length` is omitted or exceeds the string length. The first character of the string has index 0.
         The result is empty if there is an error parsing `From` or `Length`, if `From` is beyond the end of the string,
         or if `Length` is negative.
         
         Extracting substrings from strings with quotes is dangerous as it can lead to imbalanced quoting.
         If the resulting string would contain any quotes, an error is reported suggesting the use of `dequote` and `requote`
         and the resulting string has its quotes replaced by control characters.
         
         Extracting substrings from UTF-8 strings (supporting unicode characters) is also dangerous. Tilde
         treats characters as bytes and UTF-8 characters can use multiple bytes, so substrings can split
         UTF-8 characters. Such split UTF-8 characters will result in bytes/Tilde-characters that have no
         special treatment in Tilde. They can be rejoined to reform valid UTF-8 strings.
         
         When evaluating substrings, care must be taken with `,`, `(`, and `)` because of their meaning in argument parsing.  
         
         `substr` is a slow operation relative to `substr_eval` (due to limitations of M4).
         O: the substring or its evaluation
         E: m5_substr(['Hello World!'], 3, 5)
         P: lo Wo
         A: (m_dequote, m_requote)
      <">, String: the string, From: the starting position of the substring, ?Length: the length of the substring)
      
      ~DocFn(join, <">
         O: the arguments, delimited by the given delimiter string
         E: m5_join([', '], ['one'], ['two'], ['three'])
         P: one, two, three
      <">, Delimiter: text to delimit arguments, ...: arguments to concatenate (with delimitation))

      ~DocFns(['translit, translit_eval'], <">
         D: Transliterate a string, providing a set of character-for-character substitutions (where a character
         is a unicode byte). `translit_eval` evaluates the resulting string.
         Note that `['` and `']` are internally single characters. It is possible to
         substitute these quotes (if balanced in the string and in the result) using `translit_eval` but not using `translit`.
         O: the transliterated string (or its evaluation for `translit_eval`)
         S: for `translit_eval`, the side-effects of the evaluation
         E: m5_translit(['Testing: 1, 2, 3.'], ['123'], ['ABC'])
         P: Testing: A, B, C.
      <">, String: the string to tranliterate, InChars: the input characters to replace, OutChars: the corresponding character replacements)

      ~DocFns(['uppercase, lowercase'], <">
         D: Convert upper-case ASCII characters to lower-case.
         O: the converted string
         E: m5_uppercase(['Hello!'])
         P: HELLO!
      <">, String: the string)

      ~DocFn(replicate, <">
         D: Replicate a string the given number of times. (A non-evaluating version of `m5_repeat`.)
         O: the replicated string
         E: m5_replicate(3, ['.'])
         P: ...
         A: (m_repeat)
      <">, Cnt: the number of repetitions, String: the string to repeat)

      ~DocFn(strip_trailing_whitespace_from, <">
         D: Strip trailing whitespace from the given variable.
         S: the variable is updated
      <">, Var: the variable)
      ~("

         ==== Formatting Strings

      ")
      ~DocFn(format_eval, <">
         D: Produce formatted output, much like the C `printf` function. The `string` argument may contain `%`
         specifications that format values from `...` arguments.

         From the https://www.gnu.org/software/m4/manual/m4.html#Format[M4 Manual], `%` specifiers include
         `c`, `s`, `d`, `o`, `x`, `X`, `u`, `a`, `A`, `e`, `E`, `f`, `F`, `g`, `G`, and `%`. The following are also supported:
         
         - field widths and precisions
         - flags `+`, `-`, ` `, `0`, `#`, and `'`
         - for integer specifiers, the width modifiers `hh`, `h`, and `l`
         - for floating point specifiers, the width modifier `l`
         
         Items not supported include positional arguments, the `n`, `p`, `S`, and `C` specifiers, the `z`,
         `t`, `j`, `L` and `ll` modifiers, escape sequences, and any platform extensions available in the native printf (for example,
         `%a` is supported even on platforms that haven’t yet implemented C99 hexadecimal floating point output natively).
         
         For more details on the functioning of `printf`, see the C Library Manual, or the POSIX specification.
         O: the formatted string
         E: 1: m5_var(Foo, Hello)
            m5_format_eval(`String "%s" uses %d chars.', Foo, m5_length(Foo))
         2: m5_format_eval(`%*.*d', `-1', `-1', `1')
         3: m5_format_eval(`%.0f', `56789.9876')
         4: m5_length(m5_format(`%-*X', `5000', `1'))
         5: m5_format_eval(`%010F', `infinity')
         6: m5_format_eval(`%.1A', `1.999')
         7: m5_format_eval(`%g', `0xa.P+1')
         P: 1: 
            String "Hello" uses 5 chars.
         2: 1
         3: 56790
         4: 5000
         5:        INF
         6: 0X2.0P+0
         7: 20
      <">, string: the string to format, ...: ['values to format, one for each `%` sequence in `string`'])
      ~("

         ==== Inspecting Strings

      ")
      ~DocFn(length, <">
         O: the length of a string in ASCII characters (unicode bytes)
      <">, String: the string)
      
      ~DocFn(index_of, <">
         O: the position in a string in ASCII characters (unicode bytes) of the first occurence of a given substring or -1 if not present, where the string starts with character zero
      <">, String: the string, Substring: the substring to find)

      ~DocFn(num_lines, <">
         O: the number of new-lines in the given string
      <">, String: the string)
      
      ~DocFn(for_each_line, <">
         D: Evaluate `m5_Body` for every line of `m5_Text`, with `m5_Line` assigned to the line (without any new-lines).
         O: output from `m5_Body`
         S: side-effects of `m5_Body`
      <">, Text: the block of text, Body: ['the body to evaluate for every `m5_\if` of `m5_\Text`'])
      ~("

      ==== Safely Working with Strings

      ")
      ~DocFns(['dequote, requote'], <">
         D: For strings that may contain quotes, working with substrings can lead to imbalanced quotes
         and unpredictable behavior. `dequote` replaces quotes for (different) control-character/byte quotes, aka "surrogate-quotes"
         that have no special meaning. Dequoted strings can be safely sliced and diced, and once reconstructed into
         strings containing balanced (surrogate) quotes, dequoted strings can be requoted using `requote`.
         O: dequoted or requoted string
      <">, String: the string to dequote or requote)

      ~DocFn(output_with_restored_quotes, <">
         O: the given string with quotes, surrogate quotes and printable quotes replaced by their original format ([''])
         A: (m_printable_open_quote, m_printable_close_quote)
      <">, String: the string to output)

      ~DocFn(no_quotes, <">
         D: Assert that the given string contains no quotes.
      <">, String: the string to test)
      ~("

         ==== Regular Expressions

         Regular expressions in Tilde use the same regular expression syntax as GNU Emacs. (See
         https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexps.html[GNU Emacs Regular Expressions].)
         This syntax is similar to BRE, Basic Regular Expressions in POSIX and is regrettably rather limited.
         Extended Regular Expressions are not supported.

      ")
      /**
      m5_DocFn(, <">
         D: 
         O: 
         S: none
         E: 
         P: 
         A: ()
      <">, ...: )
      **/

      ~DocFns(['regex, regex_eval'], <">
         D: Searches for the first occurence of `Regexp` in `String`, resulting in either the position of the match
         or its replacement.
         
         `Replacement` provides the output text. It may contain references to subexpressions of `Regex` to expand
         in the output. In `Replacement`, `\n` references the nth parenthesized subexpression of `Regexp`, up to nine
         subexpressions, while `\&` refers to the text of the entire regular expression matched. For all other
         characters, a preceding `\` treats the character literally.
         O: If `Replacement` is omitted, the index of the first match of `Regexp` in `String` is produced (where the
         first character in the string has an index of 0), or -1 is produced if there is no match.
         
         If `Replacement` is given and there was a match, this argument provides the output, with `\n`
         replaced by the corresponding matched subexpressions of `Regex` and `\&` replaced by the entire matched
         substring. If there was no match result is empty.
         
         The resulting text is literal for `regex` and is evaluated for `regex_eval`.
         S: `regex_eval` may result in side-effects resulting from the evaluation of `Replacement`. 
         E: m5_regex_eval(['Hello there'], ['\w+'], ['First word: m5_translit(['\&']).'])
         P: First word: Hello.
         A: (m_var_regex, m_if_regex, m_for_each_regex)
      <">, String: the string to search,
         Regex: the regular expression to match,
         ?Replacement: the replacement)

      ~DocFn(var_regex, <">
         D: Declare variables assigned to subexpressions of a regular expression.
         S: `status` is assigned, non-empty iff no match.
         E: m5_var_regex(['mul A, B'], ['^\(\w+\)\s+\(w+\),\s*\(w+\)$'], (Operation, Src1, Src2))
         m5_if_so(['m5_DEBUG(Matched: m5_Src1[','] m5_Src2)'])
         m5_else(['m5_error(['Match failed.'])'])
         A: (m_regex, m_regex_eval, m_if_regex, m_for_each_regex)
      <">, String: the string to match,
         Regex: the Gnu Emacs regular expression,
         VarList: a list in parentheses of variables to declare for subexpressions)

      ~DocFns(['if_regex, else_if_regex'], <">
         D: For chaining `var_regex` to parse text that could match a number of formats.
         Each pattern match is in its own scope. `else_if_regex` does nothing if `m5_status` is non-empty.
         O: output of the matching body
         S: `m5_status` is non-null if no expression matched; side-effects of the bodies
         E: ~if_regex(m5_Instruction, ['^mul\s+\(w+\),\s*\(w+\)$'], (Src1, Src2), [
            ~calc(m5_Src1 * m5_Src2)
         ], ['^incr\s+\(w+\)$'], (Src1), [
            ~calc(m5_Src1 + 1)
         ])
         A: (m_var_regex)
      <">, String: the string to match,
         Regex: the Gnu Emacs regular expression,
         VarList: a list in parentheses of variables to declare for subexpressions,
         Body: the body to evaluate if the pattern matches,
         ...: ['else body or additional repeated Regex, VarList, Body, ... to process if pattern doesn't match'])

      ~DocFn(for_each_regex, <">
         D: Evaluate body for every pattern matching regex in the string. <<v_status>> is unassigned.
         S: side-effects of evaluating the body
         E: m5_for_each_regex(H1dd3n D1git5, ['\([0-9]\)'], (Digit), ['Found m5_Digit. '])
         P: Found 1. Found 3. Found 1. Found 5. 
         A: (m_regex, m_regex_eval, m_if_regex, m_else_if_regex)
      <">, String: the string to match (containing at least one subexpression and no `$`),
         Regex: the Gnu Emacs regular expression,
         VarList: a (non-empty) list in parentheses of variables to declare for subexpressions,
         Body: the body to evaluate for each matching expression)
      ~("

         === Utilities
      
         ==== Fundamental Macros

      ")
      ~DocFn(defn, <">
         O: the M4 definition of a macro; note that the M4 definition is slightly different from the Tilde definition
      <">, Name: the name of the macro)

      ~DocFn(call, <">
         D: Call a macro. Versus directly calling a macro, this indirect mechanism has two primary uses.
         First it provides a consistent syntax for calls with zero arguments as for calls with a non-zero
         number of arguments. Second, the macro name can be constructed.
         O: the output of the called macro
         S: the side-effects of the called macro
         E: m5_call(error, ['Fail!'])
         A: (m_comma_shift, m_comma_args)
      <">, Name: the name of the macro to call, ...: the arguments of the macro to call)

      ~DocFn(quote, <">                  
         O: a comma-separated list of quoted arguments, i.e. `${empty}@`, thus turning multiple arguments into a single literal string.
         E: m5_quote(A, ['B'])
         P: ['A'],['B']
         A: (m_nquote)
      <">, ...: arguments to be quoted)
      
      ~DocFn(nquote, <">
         O: the arguments within the given number of quotes, the innermost applying individually to
         each argument, separated by commas. A `num` of `0` results in the inlining of `${empty}@`.
         E: 1: m5_nquote(3, A, ['m5_nl'])
         2: m5_nquote(3, m5_nquote(0, A, ['m5_\nl'])xx)
         P: 1: ['['['A'],['m5_\nl']']']
         2: ['['['A'],['m5_\nlxx']']']
         A: (m_quote)
      <">, ...: )
      
      ~DocFn(eval, <">
         D: Evaluate the argument.
         O: the result of evaluating the argument
         S: the side-effects resulting from evaluation
         E: 1: m5_eval(['m5_calc(1 + 1)'])
         2: m5_eval(['m5'])_calc(1 + 1)
         P: 1: 2
         2: m5_calc(1 + 1)
      <">, Expr: the expression to evaluate)

      ~DocFns(['comment, nullify'], <">
         O: nothing at all; used to provide a comment (though <<comments>> are preferred) or to discard the result of an evaluation
      <">, ...: )
      ~("
         
         ==== Manipulating Macro Stacks

         See <<Macro Stacks>>.

      ")
      ~DocFns(['get_ago'], <">
         O: ['a value from a variable's stack, or empty if not defined']
         E: *{
            var(Foo, A)
            var(Foo, B)
            ~get_ago(Foo, 1)
            ~get_ago(Foo, 0)
         }
         P: AB
      <">, Name: variable name, Ago: ['0 for current definition, 1 for previous, and so on'])

      ~DocFn(depth_of, <">
         O: the number of values on a variable's stack
         E: m5_depth_of(Foo)
         m5_push_var(Foo, A)
         m5_depth_of(Foo)
         P: 0
         
         1
      <">, Name: macro name)
      ~("

         ==== Argument Processing

      ")
      ~DocFns(['shift, comma_shift'], <">
         D: Removes the first argument. `comma_shift` includes a leading `,` if there are more than zero arguments.
         O: a list of remaining arguments, or `['']` if less than two arguments
         S: none
         E: m5_foo(m5_shift($@))         //<"><">/ $@ has at least 2 arguments
         m5_call(foo['']m5_comma_shift($@)) //<"><">/ $@ has at least 1 argument
      <">, ...: arguments to shift)

      ~DocFn(nargs, <">
         O: the number of arguments given (useful for variables that contain lists)
         E: m5_set(ExampleList, ['hi, there'])
         m5_nargs(m5_ExampleList)
         m5_nargs(m5_eval(m5_ExampleList))
         P:
         1 
         2
      <">, ...: arguments)

      ~DocFn(argn, <">
         O: the nth of the given `arguments` or `['']` for non-existent arguments
         E: m5_argn(2, a, b, c)
         P: b
      <">, ArgNum: the argument number (n) (must be positive), ...: arguments)

      ~DocFn(comma_args, <">
         D: Convert a quoted argument list to a list of arguments with a preceding comma.
         This is necessary to properly work with argument lists that may contain zero arguments.
         E: m5_call(foo['']m5_comma_args(['$@']), last)
         A: (m_comma_shift, m_comma_fn_args)
      <">, ...: quoted argument list)

      /** Deprecated. Use above instead for better consistency
      ~DocFn(call_varargs, <">
         D: For working with argument lists that can have zero arguments, this is a bit cleaner
         looking that using `m5_comma_args` for common cases. This is a variant of `m5_call` that has a
         final argument that is a list of 0 or more additional arguments.
         E: m5_call_varargs(my_fn, arg1, ['$@'])
         A: (m_comma_args)
      <">, ...: quoted, argument list)
      **/
      
      ~DocFn(echo_args, <">
         D: For rather pathological use illustrated in the example, ...
         O: the argument list (`${empty}@`)
         E: m5_macro(append_to_paren_list, ['m5_echo_args$1, ${empty}2'])
         m5_append_to_paren_list((one, two), three)
         P: (one,two,three)
      <">, ...: the arguments to output)

      /**
      ~DocFn(, <">
         D: 
         O: 
         S: none
         E: 
         P: 
         A: ()
      <">, ...: )
      **/
      ~("

         ==== Arithmetic Macros

      ")
      ~DocFn(calc, <">
         D: Calculate an expression.
         Calculations are done with 32-bit signed integers. Overflow silently results in wraparound.
         A warning is issued if division by zero is attempted, or if the expression could not be parsed.
         Expressions can contain the following operators, listed in order of decreasing precedence.

         - `()`: For grouping subexpressions
         - `+`, `-`, `~`, `!`: Unary plus and minus, and bitwise and logical negation
         - `**`: Exponentiation (exponent must be non-negative, and at least one argument must be non-zero)
         - `*`, `%`: Multiplication, division, and modulo
         - `+ -`: Addition and subtraction
         - `<<`, `>>`: Shift left or right (for shift amounts > 32, the amount is implicitly ANDed with `0x1f`)
         - `>`, `>=`, `<`, `<=`: Relational operators
         - `==`, `!=`: Equality operators
         - `&`: Bitwise AND
         - `^`: Bitwise XOR (exclusive or)
         - `\|`: Bitwise OR
         - `&&`: Logical AND
         - `\|\|`: Logical OR

         All binary operators, except exponentiation, are left-associative. Exponentiation is right-associative.
         
         Immediate values in `Expr` may be expressed in any radix (aka base) from 1 to 36 using prefixes as follows:
         
         - (none): Decimal (base 10)
         - `0`: Octal (base 8)
         - `0x`: hexadecimal (base 16)
         - `0b`: binary (base 2)
         - `0r#:` where `#` is the radix in decimal (base `r`)
         
         Digits are `0`, `1`, `2`, …, `9`, `a`, `b` … `z`. Lower and upper case letters can be used
         interchangeably in numbers and prefixes. For radix 1, leading zeros are ignored, and all remaining
         digits must be `1`.

         For the relational operators, a true relation returns 1, and a false relation return 0.
         O: the calculated value of the expression in the given `Radix`; the value is zero-extended as requested by `Width`; values may
         have a negative sign (`-`) and they have no radix prefix; digits > 9 use lower-case letters; output is empty if the expression is invalid
         E: 1: m5_calc(2**3 <= 4)
         2: m5_calc(-0xf, 2, 8)
         P: 1: 0
         2: -00001111
      <">, Expr: the expression to calculate,
         ?Radix: the radix of the output (default 10),
         ?Width: ['a minimum width to which to zero-pad the result if necessary (excluding a possible negative sign)'])

      ~DocFns(['equate, operate_on'], <">
         D: Set a variable to the result of an arithmetic expression computed by <<m_calc>>. For
         `m5_operate_on`, the variable value implicitly preceeds the expression, similar to `+=`, `*=`, etc. in other languages.
         S: the variable is set
         E: m5_equate(Foo, 1+2)
         m5_operate_on(Foo, * (3-1))
         m5_Foo
         P: 
         
         6
         A: (m_set, m_calc)
      <">, Name: name of the variable to set, Expr: the expression/partial-expression to evaluate)

      ~DocFns(['increment, decrement'], <">
         D: Increment/decrement a variable holding an integer value by one or by the given amount.
         S: the variable is updated
         E: m5_increment(Cnt)
         A: (m_set, m_calc, m_operate_on)
      <">, Name: name of the variable to set, ?Amount: ['the integer amount to increment/decrement, defaulting to zero'])
      ~("

         ==== Boolean Macros
      
         These have boolean (`0` / `1`) results. Note that some <<m_calc>> expressions result in boolean values as well.
      
      ")
      ~DocFns(['is_null, isnt_null'], <">
         O: [`0` / `1`] indicating whether the value of the given variable (which must exist) is empty
      <">, Name: the variable name)

      ~DocFns(['eq, neq'], <">
         O: [`0` / `1`] indicating whether the given `String1` is/is-not equivalent to `String2` or any of the remaining string arguments
         E: m5_if(m5_neq(m5_Response, ok, bad), ['m5_error(Unknown response: m5_Response.)'])
      <">, String1: the first string, String2: the second string, ...: further strings to also compare)
      ~("

         ==== Within Functions or Code Blocks

      ")
      ~DocFns(['fn_args, comma_fn_args'], <">
         D: `m5_fn_args()` results in an unquoted list containing the numbered argument (each individually quoted) of the current function.
         This is like `${empty}@`, but it can be more convenient in nested functions where the use of
         <<block_labels>> (e.g. `${empty}<label>@`) would be needed. `m5_comma_fn_args()` is the same, but has a preceeding comma if the list is
         non-empty. Note that these can be used as variables (`m5_fn_args` and `m5_comman_fn_args`) to provide quoted versions of these.
         O: 
         S: none
         E: m5_foo(1, m5_fn_args())           //<"><">/ works for 1 or more fn_args
         m5_foo(1['']m5_comma_fn_args())   //<"><">/ works for 0 or more fn_args
         A: (m_fn_arg, m_fn_arg_cnt)
      <">)
      
      ~DocFn(fn_arg, <">
         D: Access a function argument by position from `m5_fn_args`.
         This is like, e.g. `${empty}3`, but it can be more convenient in nested functions where the use of
         <<block_labels>> (e.g. `${empty}<label>3`) would be needed, and
         can be parameterized (e.g. `m5_fn_arg(m5_ArgNum)`).
         O: the argument value.
         A: (m_fn_args, m_fn_arg_cnt)
      <">, Num: the argument number)

      ~DocFn(fn_arg_cnt, <">
         D: The number of arguments in `m5_fn_args` or `${empty}#`.
         This is like, e.g. `${empty}#`, but it can be more convenient in nested functions where the use of
         <<block_labels>> (e.g. `${empty}<label>#`) would be needed.
         O: the argument value.
         A: (m_fn_args, m_fn_arg)
      <">)

      ~DocFns(['out, out_eval'], <">
         D: These append to code block output that is expanded after the evaluation of the block. `m5_out` captures
         literal text, while the argument to `m5_out_eval` gets evaluated. Thus `m5_out_eval` is useful for code
         block side effects. `m5_out` is useful only in pathological cases within statements and by dynamically
         constructed code since the shorthand syntax `~(...)` is effectively identical to `~out(...)`.
         Note that these macros are not recommended for use in function blocks as functions have their own
         mechanism for side effects that applies outside of the function (after popping parameters). (See <<Aftermath>>.)
         O: no direct output, though, since these indirectly result in output as a side-effect, it is recommended to use `~`
         statement syntax with these
         S: indirectly, `out_eval` can result in the side effects of its output expression
         A: (Code Blocks, Aftermath)
      <">, String: the string to output)

      ~DocFn(return_status, <">
         D: Provide return status. (Shorthand for `m5_on_return(set, status, m5_Value)`.) This negates any prior calls
         to `return_status` from the same function.
         S: sets `m5_status`
         A: (m_on_return, v_status, returning_status, Aftermath)
      <">, ?Value: ['the status value to return, defaulting to the current value of `m5_\status`'])
      
      ~DocFn(on_return, MacroName, ..., <">
         D: Call a macro upon returning from a function. Arguments are those for m5_call.
         This is most often used to have a function declare or set a variable/macro as a side effect.
         It is also useful to perform a tail recursive call without growing the call stack.
         S: that of the resulting function call
         E: fn(set_to_five, VarName, {
            on_return(set, m5_VarName, 5)
         })
         fn(set2, VarName1, Val1, VarName2, Val2, {
            ...
            on_return(eval, {
               set(VarName1, m5_Val1)
               set(VarName2, m5_Val2)
            })
         })
         A: (m_return_status, Aftermath)
      <">, MacroName: ['the name of the macro to call'], ...: ['its arguments'])
      ~("

      === Checking and Debugging

      ")
      /**
      ~DocFn(, <">
         D: 
         O: 
         S: none
         E: 
         P: 
         A: ()
      <">, ...: )
      **/
      
      ~DocFn(debug_level, <">
         D: Get or set the debug level.
         O: with zero arguments, the current debug level
         S: sets `debug_level`
         E: debug_level(max)
         use(m5-1.0)
      <">, ?level: ['[`min`, `default`, `max`] the debug level to set'])
      ~("

         ==== Checking and Reporting to STDERR
         
         These macros output text to the standard error output stream (STDERR) (with `[{empty}'` / `'{empty}]` quotes represented by single characters).
         (Note that STDOUT is the destination for the evaluated output.)
      
      ")
      ~DocFns(['errprint, errprint_nl'], <">
         D: Write to STDERR stream (with a trailing new-line for `errprint_nl`).
         E: m5_errprint_nl(['Hello World.'])
      <">, text: ['the text to output'])

      ~DocFns(['warning, error, fatal_error, DEBUG'], <">
         D: Report an error/warning/debug message and stack trace (except for `DEBUG`).
         Exit for fatal_error, with non-zero exit code.
         E: m5_error(['Parsing failed.'])
      <">, message: ['the message to report; (`Error:` pre-text (for example) provided by the macro)'])

      ~DocFns(['warning_if, error_if, fatal_error_if, DEBUG_if'], <">
         D: Report an error/warning/debug message and stack trace (except for `DEBUG_if`) if the given condition is true.
         Exit for fatal_error, with non-zero exit code.
         E: m5_error_if(m5_Cnt < 0, ['Negative count.'])
      <">, condition: ['the condition, as in `m5_\if`.'], message: ['the message to report; (`Error:` pre-text (for example) provided by the macro)'])

      ~DocFns(['assert, fatal_assert'], <">
         D: Assert that a condition is true, reporting an error if it is not, e.g. `Error: Failed assertion: -1 < 0`. Exit for fatal_error, with non-zero exit code.
         E: m5_assert(m5_Cnt < 0)
      <">, condition: ['the condition to check (and report)'])

      doc_as_fn(verify_min_args, <">
      <">, Name, Min, Actual)
      doc_as_fn(verify_num_args, <">
      <">, Name, Min, Actual)
      ~DocFns(['verify_min_args, verify_num_args, verify_min_max_args'], <">
         D: Verify that a traditional macro has a minimum number, a range, or an exact number of arguments.
         E: m5_verify_min_args(my_fn, 2, $#)
      <">, Name: the name of this macro (for error message), Min: the required minimum or exact number of arguments,
         Max: the maximum number of arguments, Actual: the actual number of arguments)
      ~("

         ==== Uncategorized Debug Macros

      ")
      ~DocVar(recursion_limit, <">
         D: If the function call stack exceeds this value, a fatal error is reported.
      <">)

      ~DocFn(abbreviate_args, <">
         D: For reporting messages containing argument lists, abbreviate long arguments and/or a long argument list by replacing
            long input args and remaining arguments beyond a limit with ['...'].
         O: a quoted string of quoted args with a comma preceding every arg.
         E: m5_abbreviate_args(5, 15, $@)
      <">, max_args: ['if more than this number of args are given, additional args are represented as ['...']'],
         max_arg_length: ['maximum length in characters to display of each argument'],
         ...: ['arguments to represent in output'])
   ])



   macro(tail_doc, <">
      
      == Reference Card

      Tilde processes the following syntaxes:

      [cols="3,2,4,3,2a"]
      [[syntax_table]]
      .Core Syntax
      |===
      |Feature |Reference |Syntax |Contexts |Must Be Evaluated?

      |Tilde comments
      |<<Comments>>
      |`/{empty}//`, `/']['{empty}*{empty}*`, `{empty}*{empty}*']['/`
      |All
      |N/A

      |Quotes
      |<<Quotes>>
      |`['`, `']`
      |All
      |Yes

      |Macro calls
      |<<Calling Macros>>
      |e.g. `m5_my_fn(arg1, arg2)`
      |All (except as code statement)
      |Yes

      |Numbered/special parameters
      |<<Declaring Macros>>
      |`$` (e.g. `${empty}3`, `${empty}@`, `${empty}#`, `${empty}*`)
      |Within outermost macro/function (not var) definition body
      |N/A

      |Escapes
      |<<prefix_escapes>>
      |`\']['m5_foo`, `m5_\foo`
      |All
      |`\']['m5_foo`-Yes, `m5_\foo`-Must not
      |===

      The contexts listed under the "Contexts" column of <<syntax_table>> are described in <<Contexts>>. "Yes" in the
      "Must Be Evaluated" column indicates that the syntax should not pass through to the output without being evaluated.
      Doing so may result in an error or unexpected output text.
      
      Additionally, text and code block syntax is recognized when special quotes are opened at the end of a line or closed
      at the beginning of a line. See <<Code Blocks>>. For example:

       /Report error.
       error(*<blk>{
          ~(['Something went wrong!'])
       })

      Block syntax incudes:

      [cols="3,2,4,3a"]
      [[block_syntax]]
      .Block Syntax
      |===
      |Feature |Reference |Syntax |Contexts

      |Code block quotes
      |<<Code Blocks>>
      |`[`, `]`, `{`, `}` (ending/beginning a line)
      |Tilde, code

      |Text block quotes
      |<<Text Blocks>>
      |`['`, `']` (ending/beginning a line)
      |Tilde, code

      |Evaluate Blocks
      |<<Evaluate Blocks>>
      |`{empty}*[`, `[`, `{empty}*{`, `}`, `*['`, `']`
      |Tilde, code

      |Statement comment
      |<<statement_comments>>
      |`/Blah blah blah...`
      |Code

      |Statement with no output
      |<<Code Blocks>>
      |`Foo`, `bar(...)` (`m5_` prefix implied)
      |Code

      |Code block statement with output
      |<<bCode Blocks>>
      |`~Foo`, `~bar(...)` (`m5_` prefix implied)
      |Code

      |Code block output
      |<<Code Blocks>>
      |`~(...)`
      |Code
      |===

      All syntax in <<block_syntax>> must be evaluated (strictly, must not be unevaluated).

      Though not essential, block labels can be used to improve maintainability and performance in extreme cases.

      [cols="3,2,4,3, 2a"]
      .Block Label Syntax
      |===
      |Feature |Reference |Syntax |Contexts |Must Be Evaluated

      |Named blocks
      |<<block_labels>>
      |`<foo>` (preceding the open block quote, after optional `{empty}*`) e.g. `{empty}*<bar>{` or `<baz>[{empty}'`
      |Tilde, Code
      |Yes

      |Quote escape
      |<<block_labels>>
      |`'{empty}]<foo>m5_Bar[{empty}'`
      |All (within any type of Tilde quotes)
      |`<foo>m5_Bar`-Yes

      |Labeled number/special parameter reference
      |<<block_labels>>
      |`${empty}<foo>`, e.g. `${empty}<foo>2` or `${empty}<bar>#`
      |All (within corresponding block)
      |N/A
      |===

      Many macros accept arguments with syntaxes of their own, defined in the macro definition. Functions, for example are fundamental. See <<Functions>>.

      /**
      == Thoughts for M6
      
      === Special Characters
      
      If only we could reserve a few characters specifically for Tilde (for "m5_", quotes, and commas especially,
      and parentheses would be nice too). Alas, there is no standard, global way to type non-ascii characters.

      === Literal vs. Source Quotes
      
      It might be nice to have different flavors of quotes for literal text vs. text that is to be evaluated (source).
      Literal text would not parse for macros and quotes other than the corresponding end quote.
      We could add checking that the final output does not contain any source strings and that literals are
      not evaluated. This would be problematic, though in that it requires adding characters to the strings
      while would throw off things like string length. It is difficult, also, to add runtime checks against
      things like contatenating literals with source strings. So this requires a new (non-M4-based) implementation.
      
      **/

      [index]
      == Index


   <">)
])
m5_output_with_restored_quotes(m5_main_doc)
m5_output_with_restored_quotes(m5_mac_spec)
m5_output_with_restored_quotes(m5_defn(tail_doc))
